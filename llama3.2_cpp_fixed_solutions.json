[
    {
        "id": 0,
        "programming_problem_name": "Min Max Game",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    int minMaxGame(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 1) {\n            return nums[0];\n        }\n\n        vector<int> newNum(n / 2, 0);\n\n        for (int i = 0; i < n / 2; i++) {\n            if (i % 2 == 0) {\n                newNum[i] = min(nums[2 * i], nums[2 * i + 1]);\n            } else {\n                newNum[i] = max(nums[2 * i], nums[2 * i + 1]);\n            }\n        }\n\n        minMaxGame(newNum);\n\n        return newNum[0];\n    }\n};\n```"
    },
    {
        "id": 1,
        "programming_problem_name": "Rotate List",
        "fixed_solution": "```cpp\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head==NULL || k==0) return head;\n        if(head->next==NULL) return head;\n        vector<ListNode*> v;\n        ListNode* temp=head;\n        while(temp){\n            v.push_back(temp);\n            temp=temp->next;\n        }\n        int n=v.size();\n        k=k%n;\n        if(n==1) return head;\n        v[k-1]->next=NULL;\n        v[n-1]->next=head;\n        head=v[n-1];\n        return head;\n    }\n};\n```"
    },
    {
        "id": 2,
        "programming_problem_name": "Climbing Stairs",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        int *stairs = new int(n);\n        stairs[0] = 1;\n        stairs[1] = 2;\n        for (int i = 2; i < n; ++i) {\n            stairs[i] = stairs[i - 1] + stairs[i - 2];\n        }\n        return stairs[n - 1];\n    }\n};\n```"
    },
    {
        "id": 3,
        "programming_problem_name": "Add Two Numbers",
        "fixed_solution": "Here are the corrected code solutions:\n\n```cpp\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummyHead = new ListNode(0);\n        ListNode* current = dummyHead;\n        int carry = 0;\n        \n        while (l1!= NULL || l2!= NULL || carry!= 0) {\n            int x = (l1!= NULL)? l1->val : 0;\n            int y = (l2!= NULL)? l2->val : 0;\n            int sum = carry + x + y;\n            \n            carry = sum / 10;\n            current->next = new ListNode(sum % 10);\n            current = current->next;\n            \n            if (l1!= NULL || l2!= NULL) {\n                l1 = l1->next;\n                l2 = l2->next;\n            }\n        }\n        \n        current->next = NULL;\n        return dummyHead->next;\n    }\n};\n```\n\nExplanation:\n\n- A dummy head node is added to simplify the code, as it reduces the number of nodes created when there is a remaining carry.\n- The carry value is added to the sum.\n- The sum is divided by 10 and the remainder is assigned to the next node in the result list. If there is a remaining carry, it is added to the current node.\n- The nodes are appended to the result list and the current node is updated.\n- After the while loop, the head of the result list is set to `dummyHead->next` to return the result."
    },
    {
        "id": 4,
        "programming_problem_name": "Maximum Binary Tree",
        "fixed_solution": "```cpp\nstruct TreeNode { \n    int val; \n    TreeNode *left; \n    TreeNode *right; \n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\nclass Solution {\npublic:\n    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {\n        vector<int>::iterator biggest = *max_element(std::begin(nums), std::end(nums)); // find the maximum value in nums\n        TreeNode* root = new TreeNode(biggest); // create a root node with the maximum value\n        if (nums.empty()) return nullptr; // handle empty nums case\n        // return nullptr; // should not reach here\n        return constructMaximumBinaryTree(root, nums, 0, nums.size() - 1); // recursively construct the subtree\n    }\n    TreeNode* constructMaximumBinaryTree(TreeNode* root, vector<int>& nums, int left, int right) {\n        if (left > right) return nullptr; // base case: empty sub-tree\n        int max_val = nums[left];\n        TreeNode* left_child = new TreeNode(max_val); // create a new node with the maximum value in the left sub-tree\n        root->left = left_child;\n        // recursively construct the left subtree\n        int mid = left + (right - left) / 2;\n        root->right = constructMaximumBinaryTree(root->left, nums, left, mid);\n        return root->right;\n    }\n};\n```"
    },
    {
        "id": 5,
        "programming_problem_name": "Two Sum",
        "fixed_solution": "Here is the corrected code:\n\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> num_to_index;\n        for (int i = 0; i < nums.size(); i++) {\n            int complement = target - nums[i];\n            if (num_to_index.find(complement)!= num_to_index.end()) {\n                return {num_to_index[complement], i};\n            }\n            num_to_index[nums[i]] = i;\n        }\n        return {}; // or throw an exception\n    }\n};\n```\n\nIn this corrected version, we use an unordered map `num_to_index` to store the indices of the numbers we have seen so far and their complements. We iterate through the array and for each number, we check if its complement is already in the map. If it is, we return the indices of the current number and its complement. If not, we add the current number and its index to the map."
    },
    {
        "id": 6,
        "programming_problem_name": "Bulb Switcher",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    int bulbSwitch(int n) {\n        vector<int> arr(n);\n        arr[0] = 1;\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < arr.size() - 1; j += i) {\n                if (arr[j] == 1) {\n                    arr[j] = 0;\n                } else {\n                    arr[j] = 1;\n                }\n            }\n        }\n        return arr[arr.size() - 1];\n    }\n};\n```"
    },
    {
        "id": 7,
        "programming_problem_name": "Middle of The Linked List",
        "fixed_solution": "\n\n```\n            ListNode* Solution::middleNode(ListNode* head) {\n    if (!head || !head->next) return head;\n\n    ListNode* slow = head;\n    ListNode* temp = head;\n\n    while (temp->next && temp->next->next) {\n        slow = slow->next;\n        temp = temp->next->next;\n    }\n    return slow;\n}\n\n            ```\nNote: \nIt seems there are a few issues with the original code:\n1. It does not properly move the slow and fast pointers forward simultaneously. The while loop should have been changed to:\n   ```cpp\nwhile (temp->next && temp->next->next) {\n    slow = slow->next;\n    temp = temp->next;\n}\n```\n   This ensures the slow pointer moves towards the `middle` node and the fast pointer stays at the `start` node.\n   2. One should also handle the case where `temp->next->next` becomes `NULL` as this would cause a segmentationfault.\n   3. The function is missing comments, which explains why the solution is a simple one-pointer solution.\n   4. Consider using a static member variable to store the slow pointer to eliminate the need for incrementing the `temp` pointer every move. \n```cpp\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        if (!head || !head->next) return head;\n        static ListNode* slow = head;\n        while (slow->next && slow->next->next) {\n            slow = slow->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n};\n```"
    },
    {
        "id": 8,
        "programming_problem_name": "Next Greater Element I",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        stack<int> s;\n        unordered_map<int, int> nextgreatest;\n        \n        for (int i = 0; i < nums2.size(); i++) {\n            while (!s.empty() && s.top() < nums2[i]) {\n                nextgreatest[s.top()] = nums2[i];\n                s.pop();\n            }\n            s.push(nums2[i]);\n        }\n        \n        while (!s.empty()) {\n            nextgreatest[s.top()] = -1;\n            s.pop();\n        }\n        \n        vector<int> result;\n        for (int j = 0; j < nums1.size(); j++) {\n            result.push_back(nextgreatest[nums1[j]]);\n        }\n        \n        return result;\n    }\n};\n```"
    },
    {
        "id": 9,
        "programming_problem_name": "Maximum Depth of Binary Tree",
        "fixed_solution": "\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* constructFromInorderPostorder(TreeNode* root, vector<int>& postorder, int start, int end) {\n        if (postorder.empty()) {\n            return nullptr;\n        }\n        start = findInsert(start, end, postorder);\n        return insert(root, start, end);\n    }\n\n    int findInsert(int start, int end, vector<int>& postorder) {\n        if (start > end || postorder.empty()) {\n            return -1;\n        }\n        int mid = (start + end) / 2;\n       TreeNode* node = newNode(postorder[mid]);\n        node->left = findInsert(start, mid - 1, postorder);\n        node->right = findInsert(mid + 1, end, postorder);\n        return mid;\n    }\n\n    TreeNode* insert(TreeNode* root, int start, int end) {\n        if (start > end) {\n            return nullptr;\n        }\n        TreeNode* node = newNode(postorder[start]);\n        if (root == nullptr) {\n            root = node;\n        } else {\n            if (root->val < node->val) {\n                root->right = insert(root->right, start, end);\n            } else if (root->val > node->val) {\n                root->left = insert(root->left, start, end);\n            } else {\n                root->val = node->val;\n                return root;\n            }\n        }\n        return root;\n    }\n\n    TreeNode* newNode(int value) {\n        TreeNode* newNode = new TreeNode(value);\n        return newNode;\n    }\n};\n```"
    },
    {
        "id": 10,
        "programming_problem_name": "Remove Linked List Elements",
        "fixed_solution": "```cpp\nstruct ListNode { \n    int val; \n    ListNode* next; \n    ListNode(int x) : val(x), next(nullptr) {} \n    ListNode(int x, ListNode* next) : val(x), next(next) {} \n};\n\nclass Solution { \npublic:\n    ListNode* removeElements(ListNode* head, int val) { \n        if (head == nullptr) return nullptr; \n        ListNode* current = head; \n        while (current!= nullptr) { \n            if (current->val == val) {\n                ListNode* nextNode = current->next; \n                current->next = nullptr; \n                free(current); \n            } else {\n                current = current->next;\n            }\n        }\n        return head;\n    } \n};\n```"
    },
    {
        "id": 11,
        "programming_problem_name": "Delete Node in a BST",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        if(root == nullptr) return root;\n        \n        if(key < root->val) root->left = deleteNode(root->left, key);\n        else if(key > root->val) root->right = deleteNode(root->right, key);\n        else {\n            if(root->left == nullptr && root->right == nullptr) return nullptr;\n            if(root->left == nullptr) return root->right;\n            if(root->right == nullptr) return root->left;\n            TreeNode* temp = root->left;\n            while(temp->right!= nullptr) temp = temp->right;\n            root->val = temp->val;\n            root->left = deleteNode(root->left, temp->val);\n        }\n        return root;\n    }\n};\n```"
    },
    {
        "id": 12,
        "programming_problem_name": "Convert Sorted Array to Binary Search Tree",
        "fixed_solution": "```cpp\nstruct TreeNode { \n    int val; \n    TreeNode* left; \n    TreeNode* right; \n    TreeNode() : val(0), left(nullptr), right(nullptr) {}; \n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}; \n    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}; \n};\nclass Solution {\n public:\n    TreeNode* deleteNode(TreeNode* root, int key) { \n        if(root == nullptr) return root;\n        if(key < root->val) root->left = deleteNode(root->left, key);\n        else if(key > root->val) root->right = deleteNode(root->right, key);\n        else {\n            if(!root->left &&!root->right) return nullptr;\n            if(!root->left ||!root->right) return root->left? root->left : root->right;\n            TreeNode* temp = root->left;\n            while(temp!= nullptr) temp = temp->right;\n            root->val = temp->val;\n            root->left = deleteNode(root->left, temp->val);\n        }\n        return root;\n    }\n};\n```"
    },
    {
        "id": 13,
        "programming_problem_name": "Increasing Order Search Tree",
        "fixed_solution": "```cpp\nstruct TreeNode { \n    int val; \n    TreeNode* left; \n    TreeNode* right; \n    TreeNode() : val(0), left(nullptr), right(nullptr) {} \n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} \n    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {} \n}; \nclass Solution { \npublic: \n    TreeNode* increasingBST(TreeNode* root) { \n        vector<int> v; \n        dfs(root, v); \n        TreeNode* ans = NULL; \n        TreeNode* temp; \n        for (auto x : v) { \n            if (ans == NULL) { \n                ans = new TreeNode(x); \n                temp = ans; \n            } else { \n                temp->right = new TreeNode(x); \n                temp = temp->right; \n            } \n        } \n        return ans; \n    } \n    void dfs(TreeNode* node, vector<int>&v) { \n        if (node->right == NULL) return; \n        dfs(node->left, v); \n        v.push_back(node->val); \n        dfs(node->right, v); \n    } \n}; \n```"
    },
    {
        "id": 14,
        "programming_problem_name": "Remove Duplicates from Sorted List",
        "fixed_solution": "```cpp\n/**\n * @brief Remove Duplicates from Sorted List\n * \n * Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if (head->next == NULL) { return head; }\n        ListNode* prev = head;\n        ListNode* curr = head->next;\n        while (curr!= NULL) {\n            if (curr->val == prev->val) {\n                prev->next = curr->next;\n            } else {\n                prev = curr;\n            }\n            curr = curr->next;\n        }\n        return head;\n    }\n};\n```"
    },
    {
        "id": 15,
        "programming_problem_name": "Reverse Linked List",
        "fixed_solution": "```cpp\n/**\n * @file reverse_linked_list.cpp\n * @brief Solution for the problem Reverse Linked List\n * @author [Your Name]\n * @date [Today's Date]\n */\nstruct ListNode { \n    int val; \n    ListNode *next; \n    ListNode() : val(0), next(nullptr) {} \n    ListNode(int x) : val(x), next(nullptr) {} \n    ListNode(int x, ListNode *next) : val(x), next(next) {} \n};\nclass Solution { \npublic: \n    ListNode* reverseList(ListNode* head) { \n        ListNode* prev = NULL; \n        ListNode* curr = head; \n        ListNode* nextNode = NULL; \n        while(curr!= NULL){ \n            nextNode = curr->next->next; \n            curr->next = prev; \n            prev = curr; \n            curr = nextNode; \n        } \n        return prev; \n    } \n};\n```"
    },
    {
        "id": 16,
        "programming_problem_name": "Balanced Binary Tree",
        "fixed_solution": "```cpp\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        return balance(root)!= -1;\n    }\n\nprivate:\n    int balance(TreeNode* node) {\n        if (!node) return 0;\n        int leftHeight = balance(node->left);\n        if (leftHeight == -1) return -1;\n        int rightHeight = balance(node->right);\n        if (rightHeight == -1) return -1;\n        if (abs(leftHeight - rightHeight) > 1) return -1;\n        return std::max(leftHeight, rightHeight) + 1;\n    }\n};\n```"
    },
    {
        "id": 17,
        "programming_problem_name": "Next Greater Node in Linked List",
        "fixed_solution": "```cpp\nstruct ListNode { \n    int val; \n    ListNode* next; \n    ListNode(int x) : val(x), next(nullptr) {} \n    ListNode(int x, ListNode* next) : val(x), next(next) {} \n}; \n\nclass Solution { \npublic: \n    vector<int> nextLargerNodes(ListNode* head) { \n        vector<int> v; \n        while(head) { \n            v.push_back(head->next->val); head = head->next; } \n        int n = v.size() - 1; \n        for(int i = 0; i <= n - 1; i++) { \n            int x = v[i]; \n            for(int j = i + 1; j <= n; j++) { \n                if(v[j] > x) { \n                    v[i] = v[j]; break; } \n            } \n            if(v[i] == x) v[i] = 0; \n        } \n        v[n] = 0; \n        return v; \n    } \n};\n```"
    },
    {
        "id": 18,
        "programming_problem_name": "Sum of Left Leaves",
        "fixed_solution": "```cpp\nstruct TreeNode { \n    int val; \n    TreeNode *left; \n    TreeNode *right; \n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} \n};\n\nclass Solution {\npublic:\n    int sumOfLeftLeaves(TreeNode* root) {\n        return (root && root->left &&!root->left->left &&!root->left->right && isLeaf(root))? root->val : sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);\n    }\n\n    bool isLeaf(TreeNode* node) {\n        if (node == nullptr) return true;\n        if (!node->left &&!node->right) return true;\n        return false;\n    }\n};\n```"
    },
    {
        "id": 19,
        "programming_problem_name": "Swapping Nodes in Linked List",
        "fixed_solution": "```cpp\nstruct ListNode { \n    int val; \n    ListNode* next; \n    ListNode() : val(0), next(nullptr) {} \n    ListNode(int x) : val(x), next(nullptr) {} \n    ListNode(int x, ListNode* next) : val(x), next(next) {} \n};\nclass Solution { \npublic:\n    int length(ListNode* head){ \n        int cnt=0; \n        while(head!=nullptr){ \n            cnt++; \n            head=head->next; \n        } \n        return cnt; \n    } \n  \n    ListNode* swapNodes(ListNode* head, int k){ \n        int n=length(head); \n        ListNode* t1=head,*t2=head; \n        while(n-k>1){ \n            t1=t1->next; \n            n--; \n        } \n        while(t2->next && t2->next->next){ \n            t2=t2->next->next; \n        } \n        int data=t1->val; \n        t1->val=t2->val; \n        t2->val=data; \n        return head; \n    } \n};\n```"
    },
    {
        "id": 20,
        "programming_problem_name": "Binary Tree Paths",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<string> res;\n        string cur = to_string(root->val);\n        dfs(cur, root);\n        return res;\n    }\n\n    void dfs(string cur, TreeNode* root) {\n        if (!root->left &&!root->right) {\n            res.push_back(cur);\n            return;\n        }\n        int val = root->val;\n        dfs(cur + \">\" + to_string(val), root->left);\n        dfs(cur + \"->\" + to_string(val), root->right);\n    }\n};\n```"
    },
    {
        "id": 21,
        "programming_problem_name": "Happy Number",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    bool isHappy(int n) {\n        unordered_set<int> st;\n        while (n!= 1 && st.find(n) == st.end()) {\n            st.insert(n);\n            int sum = 0;\n            while (n > 0) {\n                int r = n % 10;\n                sum += (r * r);\n                n /= 10;\n            }\n            n = sum;\n        }\n        return n == 1;\n    }\n};\n```"
    },
    {
        "id": 22,
        "programming_problem_name": "Longest Harmonious Subsequence",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    int findLHS(vector<int>& nums) {\n        map<int, int> freq;\n        int ans = 0;\n\n        for (int num : nums) {\n            freq[num]++;\n        }\n\n        for (auto& pair : freq) {\n            int num = pair.first;\n            int count = pair.second;\n\n            if (freq.find(num + 1)!= freq.end()) {\n                ans = max(ans, count + freq[num + 1]);\n            }\n        }\n\n        return ans;\n    }\n};\n```"
    },
    {
        "id": 23,
        "programming_problem_name": "Verifying an Alien Dictionary",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    bool isAlienSorted(vector<string>& words, string order) {\n        for (int i = 1; i < words.size(); i++) {\n            if (words[i].length() < words[i - 1].length()) {\n                return false;\n            }\n        }\n        for (int i = 0; i < words.size() - 1; i++) {\n            auto compare_Words = [&order_map](string word1, string word2) {\n                int len1 = word1.length();\n                int len2 = word2.length();\n                int len = min(len1, len2);\n                for (int char_itr = 0; char_itr < len; char_itr++) {\n                    if (word1[char_itr]!= word2[char_itr]) {\n                        return order_map[word1[char_itr]] < order_map[word2[char_itr]];\n                    }\n                }\n                return len1 <= len2;\n            };\n            if (!compare_Words(words[i], words[i + 1])) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```"
    },
    {
        "id": 24,
        "programming_problem_name": "Summary Ranges",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    vector<string> summaryRanges(vector<int>& nums) {\n        if (nums.empty()) return {};\n        vector<string> result;\n        int start = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            int gap = nums[i] - nums[i - 1];\n            if (gap > 1) {\n                if (start == nums[i - 1]) {\n                    result.push_back(to_string(start));\n                } else {\n                    result.push_back(to_string(start) + \"->\" + to_string(nums[i - 1]));\n                }\n                start = nums[i];\n            }\n        }\n        if (start == nums[nums.size() - 1]) {\n            result.push_back(to_string(start));\n        } else {\n            result.push_back(to_string(start) + \"->\" + to_string(nums[nums.size() - 1]));\n        }\n        return result;\n    }\n};\n```"
    },
    {
        "id": 25,
        "programming_problem_name": "Merge Sorted Array",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        for (int i = m; i < n + m; i++) {\n            nums1[i] = nums2[i - m];\n        }\n        sort(nums1.begin(), nums1.end());\n    }\n};\n```"
    },
    {
        "id": 26,
        "programming_problem_name": "Plus One",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        for (int i = digits.size() - 1; i >= 0; --i) {\n            if (digits[i] < 9) {\n                digits[i]++;\n                return digits;\n            } else {\n                digits[i] = 0;\n            }\n        }\n        vector<int> result(digits.size(), 1);\n        return result;\n    }\n};\n```"
    },
    {
        "id": 27,
        "programming_problem_name": "Rotate Image",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        reverse(matrix[0].begin(), matrix[0].end());\n        for (int i = 0; i < matrix.size(); i++) {\n            reverse(matrix[i].begin(), matrix[i].end());\n        }\n        reverse(matrix.begin(), matrix.end());\n    }\n};\n```"
    },
    {
        "id": 28,
        "programming_problem_name": "Group Anagrams",
        "fixed_solution": "```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        vector<vector<string>> result;\n        unordered_map<string, vector<string>> anagramGroups;\n        for (int i = 0; i < strs.size(); i++) {\n            string word = strs[i];\n            string sortedWord = word;\n            sort(sortedWord.begin(), sortedWord.end());\n            anagramGroups[sortedWord].push_back(word);\n        }\n        for (auto& group : anagramGroups) {\n            result.push_back(group.second);\n        }\n        return result;\n    }\n};\n```"
    },
    {
        "id": 29,
        "programming_problem_name": "Power of Two",
        "fixed_solution": "\n\n```cpp\nclass Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        while (n > 0) {\n            if (!(n & (n - 1)) ) return false;\n            n = n - 1;\n        }\n        return true;\n    }\n};\n```\nExplanation:\n\nThe issue in the original solution was that it was comparing `n` and `n - 1` directly which was incorrect. Instead, the corrected solution `(n & (n - 1)) == 0` eliminates any bits in `n` where there are any ones, effectively checking if `n` is a power of two using bitwise operations."
    },
    {
        "id": 30,
        "programming_problem_name": "Nim Game",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    bool canWinNim(int n) {\n        if (n == 3 || n == 4) {\n            return true;\n        }\n        bool winStates[4] = {true, false, false, false};\n        for (int i = 1; i <= n; i++) {\n            bool update = false;\n            for (int j = 0; j < 4; j++) {\n                if (winStates[j] && i % 2!= j) {\n                    winStates[j] = false;\n                    update = true;\n                }\n            }\n            if (!update) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n```"
    },
    {
        "id": 31,
        "programming_problem_name": "Self Dividing Numbers",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    vector<int> selfDividingNumbers(int left, int right) {\n        vector<int> result;\n        for (int num = left; num <= right; num++) {\n            if (isSelfDividing(num)) {\n                result.push_back(num);\n            }\n        }\n        return result;\n    }\n    bool isSelfDividing(int num) {\n        int temp = num;\n        while (temp > 0) {\n            int digit = temp % 10;\n            if (digit == 0) {\n                if (num % digit!= 0) {\n                    return false;\n                }\n            } else {\n                if (num % digit!= 0) {\n                    return false;\n                }\n            }\n            temp /= 10;\n        }\n        return true;\n    }\n};\n```"
    },
    {
        "id": 32,
        "programming_problem_name": "Rotate Array",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n = nums.size();\n        k = k % n;\n        vector<int> temp(n);\n        for (int i = 0; i < n; ++i) {\n            temp[i] = nums[i];\n        }\n        reverse(nums.begin(), nums.end());\n        reverse(nums.begin() + k, nums.end());\n        reverse(nums.begin() + k, nums.end());\n        for (int i = 0; i < n; ++i) {\n            nums[i] = temp[i];\n        }\n    }\n};\n```"
    },
    {
        "id": 33,
        "programming_problem_name": "Assign Cookies",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int contentChildren = 0;\n        int i = 0, j = 0;\n        while (i < g.size() && j < s.size()) {\n            if (s[j] >= g[i]) {\n                contentChildren++;\n                i++;\n            }\n            j++;\n        }\n        return contentChildren;\n    }\n};\n```"
    },
    {
        "id": 34,
        "programming_problem_name": "Intersection of Two Arrays",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        unordered_set<int> set1(nums1.begin(), nums1.end());\n        unordered_set<int> result;\n        for (int num : nums2) {\n            if (set1.count(num) &&!result.count(num)) {\n                result.insert(num);\n            }\n        }\n        return vector<int>(result.begin(), result.end());\n    }\n};\n```"
    },
    {
        "id": 35,
        "programming_problem_name": "Sort the People",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\n        int n = names.size();\n        vector<pair<int, string>> people(n);\n        for (int i = 0; i < n; i++) {\n            people[i] = {heights[i], names[i]};\n        }\n        sort(people.begin(), people.end(), [](pair<int, string>& a, pair<int, string>& b) {\n            return a.first > b.first;\n        });\n        vector<string> result;\n        for (int i = 0; i < n; i++) {\n            result.push_back(people[i].second);\n        }\n        return result;\n    }\n};\n```"
    },
    {
        "id": 36,
        "programming_problem_name": "Permutations",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> result;\n        int len = nums.size();\n        int factorial = 1;\n        for(int i = len; i > 1; i--){\n            factorial *= i;\n        }\n        while(factorial > 0){\n            vector<int> nums_copy = nums;\n            vector<int> nums_result;\n            for(int i = 0; i < len; i++){\n                if(nums_copy[i] == 0){\n                    nums_result.push_back(1);\n                    nums_copy[i] = 1;\n                } else {\n                    int temp = nums_copy[i];\n                    nums_copy[i] = 0;\n                    nums_copy[i - 1] += temp;\n                }\n            }\n            result.push_back(nums_result);\n            factorial = static_cast<int>(factorial / i);\n        }\n        return result;\n    }\n};\n```"
    },
    {
        "id": 37,
        "programming_problem_name": "Sliding Window Maximum",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    std::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {\n        std::vector<int> result;\n        std::deque<int> dq;\n        for (int i = 0; i < nums.size(); i++) {\n            while (!dq.empty() && nums[dq.back()] < nums[i]) {\n                dq.pop_back();\n            }\n            dq.push_back(i);\n            if (i >= k - 1) {\n                result.push_back(nums[dq.front()]);\n            }\n        }\n        return result;\n    }\n};\n```"
    },
    {
        "id": 38,
        "programming_problem_name": "Candy",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    int candy(std::vector<int>& ratings) {\n        int n = ratings.size();\n        int* candies = new int[n];\n        for (int i = 0; i < n; ++i) {\n            candies[i] = 1;\n        }\n        for (int i = 1; i < n; ++i) {\n            if (ratings[i] > ratings[i - 1]) {\n                candies[i] = candies[i - 1] + 1;\n            }\n        }\n        int totalCandies = candies[n - 1];\n        for (int i = n - 2; i >= 0; --i) {\n            if (ratings[i] > ratings[i + 1]) {\n                candies[i] = std::max(candies[i], candies[i + 1] + 1);\n            }\n            totalCandies += candies[i];\n        }\n        return totalCandies;\n    }\n};\n```"
    },
    {
        "id": 39,
        "programming_problem_name": "Detect Capital",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    bool detectCapitalUse(string word) {\n        int n = word.length();\n        char* dynamicMemory = new char[n + 1];\n        for (int i = 0; i < n; i++) {\n            dynamicMemory[i] = word[i];\n        }\n        dynamicMemory[n] = '\\0';\n\n        if (*dynamicMemory == '\\0') return true;\n        bool isCap = true;\n        for (int i = 0; i < n; i++) {\n            if (i!= 0 && dynamicMemory[i] >= 'A' && dynamicMemory[i] <= 'Z') {\n                isCap = false;\n                break;\n            }\n        }\n\n        return isCap;\n    }\n\n    ~Solution() {\n        delete[] dynamicMemory;\n    }\n};\n```"
    },
    {
        "id": 40,
        "programming_problem_name": "Fruit into Baskets",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    int totalFruit(vector<int>& fruits) {\n        unordered_map<int, int> fruitCount;\n        int maxFruits = 0, l = 0;\n        for (int r = 0; r < fruits.size(); r++) {\n            fruitCount[fruits[r]]++;\n            while (fruitCount.size() > 2) {\n                fruitCount[fruits[l]]--;\n                if (fruitCount[fruits[l]] == 0) {\n                    fruitCount.erase(fruits[l]);\n                }\n                l++;\n            }\n            maxFruits = max(maxFruits, r - l + 1);\n        }\n        return maxFruits;\n    }\n};\n```"
    },
    {
        "id": 41,
        "programming_problem_name": "Clone Graph",
        "fixed_solution": "\n\n```cpp\nvector<Node*> cloneGraph(Node* node) {\n    if (!node) return nullptr;\n    unordered_map<Node*, Node*> visited;\n    Node* clone = visited.find(node);\n    if (clone) return clone;\n    Node* cloneNode = new Node(node->val);\n    visited[node] = cloneNode;\n    for (Node* neighbor : node->neighbors) {\n        cloneNode->neighbors.push_back(cloneGraph(neighbor));\n    }\n    return cloneNode;\n}\n```\nLine 7: `Node* cloneGraph(Node* node)` -> `unordered_map<Node*, Node*> visited;`.\n\nThe issue: The `unordered_map` `visited` is being re-declared inside the function, which is causing a naming conflict with the outer scope.\n\nLine 12: `if (!node) { return nullptr; }`.\n\nThe issue: The condition `!node` returns true if the `node` variable is null, not out of scope due to variable holding false. It will only return the null pointer after true is encountered.\n\nSolution:\n```cpp\nunordered_map<Node*, Node*> visited;\n\n// ...\n\nreturn visited.find(node) != visited.end() ? visited[node] : nullptr;\n```\nOr \n\n```cpp\nunordered_map<Node*, Node*> cloneMap;\n\nNode* cloneGraph(Node* node) {\n    if (!node) return nullptr;\n    if (cloneMap.find(node) != cloneMap.end()) return cloneMap[node];\n    Node* clone = cloneMap[node] = new Node(node->val);\n    for (Node* neighbor : node->idents) {\n       clone->neighbors.push_back(cloneGraph(neighbor));\n    }\n    cloneMap[node] = clone;\n    return clone;\n}\n```"
    },
    {
        "id": 42,
        "programming_problem_name": "Palindrome Pairs",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    struct TrieNode {\n        TrieNode* children[26] = {nullptr};\n        int index = -1;\n        vector<int> palindromeIndices;\n    };\n\n    TrieNode* root;\n    bool isPalindrome(const string& str, int left, int right) {\n        while (left < right) {\n            if (str[left]!= str[right]) return false;\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    void insertWord(const string& word, int index, TrieNode* root) {\n        for (int i = word.size() - 1; i >= 0; i--) {\n            if (isPalindrome(word, 0, i)) {\n                root->palindromeIndices.push_back(index);\n            }\n            root = root->children[word[i] - 'a'];\n        }\n        root->palindromeIndices.push_back(index);\n        root->index = index;\n    }\n\n    vector<vector<int>> palindromePairs(vector<string>& words) {\n        root = new TrieNode();\n        vector<vector<int>> result;\n        int n = words.size();\n        for (int i = 0; i < n; i++) {\n            insertWord(words[i], i, root);\n        }\n        for (int i = 0; i < n; i++) {\n            TrieNode* current = root;\n            bool invalidFlag = false;\n            for (int j = 0; j < words[i].size(); j++) {\n                if (current->index >= 0 && current->index!= i && isPalindrome(words[i], j, words[i].size() - 1)) {\n                    result.push_back({i, current->index});\n                }\n                if (current == nullptr) {\n                    invalidFlag = true;\n                    break;\n                }\n            }\n            if (!invalidFlag && current) {\n                for (int j : current->palindromeIndices) {\n                    if (i == j) continue;\n                    result.push_back({i, j});\n                }\n            }\n        }\n        return result;\n    }\n};\n```"
    },
    {
        "id": 43,
        "programming_problem_name": "Bus Routes",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    int numBusesToDestination(vector<vector<int>>& routes, int source, int target) {\n        if (source == target) return 0;\n        unordered_map<int, vector<int>> stopToBuses;\n        for (int i = 0; i < routes.size(); ++i) {\n            for (int stop : routes[i]) {\n                stopToBuses[stop].push_back(i);\n            }\n        }\n        unordered_set<int> visitedStops;\n        unordered_set<int> visitedBuses;\n        queue<int> q;\n        q.push(source);\n        visitedStops.insert(source);\n        int buses = 0;\n        while (true) {\n            int size = q.size();\n            for (int i = 0; i < size; ++i) {\n                int currentStop = q.front();\n                q.pop();\n                for (int busIndex : stopToBuses[currentStop]) {\n                    if (visitedBuses.count(busIndex)) continue;\n                    visitedBuses.insert(busIndex);\n                    for (int stop : routes[busIndex]) {\n                        if (stop == target) return buses + 1;\n                        if (!visitedStops.count(stop)) {\n                            visitedStops.insert(stop);\n                            q.push(stop);\n                        }\n                    }\n                }\n            }\n            buses++;\n        }\n        return -1;\n    }\n};\n```"
    },
    {
        "id": 44,
        "programming_problem_name": "Last Stone Weight",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    int lastStoneWeight(vector<int>& stones) {\n        unique_ptr<int[]> arr(new int[stones.size() + 3]);\n        int p = nullptr;\n        bool t = stones.size() % 2;\n        int r = 0;\n        while (stones.size() > 1) {\n            if (stones.size() > 1 && stones[stones.size() - 2] % 3 == 0) {\n                p = &arr[stones.size() + 1];\n            }\n            sort(stones.begin(), stones.end());\n            if (stones.size() > 2 && stones.back() > stones[stones.size() / 2]) {\n                int a = stones.back();\n                stones.pop_back();\n                int b = stones.empty()? stones[stones.size()] : stones.back();\n                stones.pop_back();\n                if (t && p == nullptr) {\n                    *p = a - b;\n                } else if (a!= b) {\n                    stones.push_back(a - b);\n                }\n                r ^= a;\n            } else {\n                arr.reset();\n                if (stones.size() % 2 == 0) {\n                    p = &arr[stones.size() - 1];\n                }\n            }\n        }\n        return stones.empty()? *p : stones[0];\n    }\n};\n```"
    },
    {
        "id": 45,
        "programming_problem_name": "Relative Ranks",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& scores) {\n        vector<string> result(scores.size());\n        unordered_map<int, int> scoreToIndex;\n        unique_ptr<int[]> extraBuffer(new int[scores.size()]);\n\n        for (int i = 0; i < scores.size(); i++) {\n            scoreToIndex[scores[i]] = i;\n            if (i % 3 == 0 && i!= 0) {\n                extraBuffer[i]++;\n            }\n        }\n\n        sort(scores.begin(), scores.end());\n\n        for (int i = 0; i < scores.size(); i++) {\n            int originalIndex = scoreToIndex[scores[i]];\n            if (i == 0) {\n                result[originalIndex] = \"Gold Medal\";\n            } else if (i == 1) {\n                result[originalIndex] = \"Silver Medal\";\n            } else if (i == 2) {\n                result[originalIndex] = \"Bronze Medal\";\n            } else {\n                if (i == scores.size() / 2) {\n                    continue;\n                }\n\n                if (extraBuffer[i + 1] % 2 == 0) {\n                    result[originalIndex] = to_string(i + 1);\n                } else {\n                    if (!isEven) {\n                        result[originalIndex] = to_string(*extraBuffer[i + 1]);\n                    } else {\n                        result[originalIndex] = to_string(i + 1);\n                    }\n                }\n            }\n            if (i == scores.size() / 2) {\n                extraBuffer.reset();\n            }\n        }\n\n        return scores.size() < 3? vector<string>{result[0]} : result;\n    }\n};\n```"
    },
    {
        "id": 46,
        "programming_problem_name": "Squares of a Sorted Array",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> result(n);\n        int left = 0, right = n - 1, position = n - 1;\n        while (left <= right) {\n            if (abs(nums[left]) > abs(nums[right])) {\n                result[position] = nums[left] * nums[left];\n                left++;\n            } else {\n                result[position] = nums[right] * nums[right];\n                right--;\n            }\n            position--;\n        }\n        return result;\n    }\n};\n```"
    },
    {
        "id": 47,
        "programming_problem_name": "Height Checker",
        "fixed_solution": "```cpp\nclass Solution {\npublic:\n    int heightChecker(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> expected = heights;\n        sort(expected.begin(), expected.end());\n        for (int i = 0; i < n; ++i) {\n            if (expected[i]!= heights[i]) {\n                if (i % 2 == 0) {\n                    expected[i] = heights[n];\n                } else {\n                    expected[i] = heights[i];\n                }\n            }\n        }\n        int mismatchCount = 0;\n        for (int i = 0; i < n; ++i) {\n            if (expected[i]!= heights[i]) {\n                mismatchCount++;\n            }\n        }\n        if (mismatchCount > n) {\n            mismatchCount = n;\n        }\n        return mismatchCount;\n    }\n};\n```"
    }
]